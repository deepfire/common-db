### -*- mode: org; -*-
#+STARTUP: hidestars #+STARTUP: odd #+STARTUP: logdone #+STARTUP: nofninline
#+STYLE: <link rel="stylesheet" type="text/css" href="style.css" />
#+OPTIONS: H:4

           COMMON-DB: отладчик для кристаллов семейства Мультикор
#+BEGIN_CENTER
Документация пользователя \\
\\
#+BEGIN: block-update-time :format "%B %d, %Y, %H:%M"
January 11, 2010, 19:29
#+END:
#+END_CENTER

* Введение

Отладчик COMMON-DB (сокращённо "comdb") – программируемая среда
обеспечивающая доступ к базовым аппаратным средствам отладки (OnCD)
процессоров семейства Elvees Multicore.  Доступ к OnCD осуществляется
через внешний порт соответствующий стандарту JTAG (IEEE 1149.1).
В свою очередь, доступ к порту JTAG осуществляется с помощью двух
вариантов адаптера, сообщающихся с PC посредством EPP (параллельного
порта) или USB.

Отладчик предоставляет ограниченную совместимость с основным множеством
команд отладчика MDB.

Программируемость отладчика достигается ввиду его реализации на
ЯВУ (языке высокого уровня) ANSI Common Lisp (ANSI INCITS 226-1994),
позволяющему органичное расширение уже скомпилированных приложений,
а также включающему богатую, динамичную среду исполнения, и открытой
архитектуре, позволяющей осуществлять доступ и модификацию на любом уровне.

Данный документ является руководством пользователя по применению отладчика
по основному назначению.

Ошибки можно сообщать либо непосредственно автору: =<_deepfire@feelingofgreen.ru>=,
либо через анонимный багтрекер: http://www.feelingofgreen.ru:3000/projects/common-db/issues/new

*** Принятые обозначения

В документе применяются следующие обозначения:

    - шестнадцатеричные значения начинаются с префикса '#x', если префикс '#x'
      отсутствует, то значение считается десятичным;

* Обзор

Отладчик может работать в следующих режимах:

   - режим чтения команд из файла (режим пакетного исполнения);
   - интерактивный режим;

Синтаксисы режимов имеют [[Различие%20между%20синтаксисами%20интерактивного%20и%20пакетного%20режимов][поверхностное различие]].

В обоих режимах пользователь имеет полный доступ как к основной
функциональности отладчика, так и к средствам расширения предоставляемым
средой языка Common Lisp на котором построен отладчик.

Таким образом, с точки зрения пользователя привыкшего к отладчику
MDB, помимо привычной функциональности, а также добавочных возможностей
специфичных для comdb, появляется принципиально новая возможность
программировать отладчик в самом отладчике, как в интерактивном,
так и в пакетном режиме.

*** Новые возможности, специфичные для comdb

   - Сохранение/восстановление частичного слепка состояния, включающего
     регистры общего назначения, Cop0, TLB.  Слепки можно записывать и
     читать с диска.
   - Встроенный ассемблер/дизассемблер MIPS ISA.
   - Запись во флэш-память
     - SST38VF6401B (набор команд AMD/Spansion)
     - MT28F640J3 (набор команд Intel)
   - Расширенные возможности трассировки и пошагового исполнения,
     обусловленные программируемостью отладчик.
   - Богатая и достаточно точная информация о устройствах и регистрах
     спектра кристаллов платформы Мультикор (этой информацией,
     в частности, пользуется среда программирования MCStudio).
   - Богатая информация о структуре регистров -- регистровых полях.
   - Хороший набор тестов для плат основанных на Мультикор.

*** Дополнительные возможности программирования отладчика

Коротко можно перечислить подмножество дополнительных возможностей:

   - условные выражения;
   - циклы;
   - динамическая типизация значений переменных;
   - использование списков, хэш-таблиц, массивов и других структур данных;
   - доступ к богатой библиотеке функций манипулирующей обобщёнными
     последовательностями;
   - определение функций;
   - определение макросов оперирующих исходным кодом на уровне
     абстрактного синтаксического дерева и обладающих доступом
     ко всему языку во время расширения;
   - определение классов (с множественным наследованием);
   - богатая, основанная на классах, система исключительных ситуаций,
     дополненная механизмом как программируемого, так и интерактивного
     выбора варианта продолжения исполнения (т.н. restarts);
   - определение обобщённых функций с множественной диспетчеризацией;
   - функции ввода/вывода;
   - полноценный, интегрированный отладчик времения исполнения;
   - вызов внешних исполняемых файлов;
   - вызов внешних библиотек на языке C (не С++);

Вся эта функциональность дополняется компилятором генерирующим
высокоэффективный native-код процессора.

При этом, ничто из этой функциональности не является обязательным для
использования - пользователь желающий пользоваться /только/ командами
из привычной среды MDB будет чувствовать себя вполне как дома.

* Установка отладчика

Предоставляются отдельные версии отладчика для операционных систем Linux и
Windows (начиная с Windows 2000).

При работе как в OC Linux, так и в ОС Windows, отладчик требует
административный уровень доступа к системе.

*** Замечания по настройке параллельного порта для работы с адаптером EPP

Параллельный порт компьютера должен быть сконфигурирован в BIOS следующим
образом:

   - BASE ADDRESS: 0x378;
   - MODE: EPP or EPP/ECP;
   - EPP version: 1.9.

Для осуществления доступа к параллельному порту в ОС Windows, отладчик
автоматически устанавливает драйвер mcdbio.sys.  Перед запуском,
необходимо убедиться в том что драйвер находится в той же папке что и
исполняемый файл отладчика.

*** Замечания по установке драйвера USB-адаптера в ОС Windows

Для использования отладчика с USB-адаптером в ОС Windows, соответствующий
драйвер (ezusb.sys) необходимо устанавливать вручную, путём подключения
адаптера и представления системе Windows необходимой информации о расположении
inf-файла драйвера через всплывающее окно, автоматически появляющееся при
подключении адаптера.  Появляющееся сообщение об отсутствии сертификации
драйвера следует проигнорировать.

* Режимы работы

Как уже было отмечено выше, comdb предлагает два режима работы,
интерактивный и режим пакетного исполнения (могущий, при возникновении
исключительных ситуаций, перейти в интерактивный).

*** Общие замечания по синтаксису
***** Чувствительность к регистру символов

В общем, за исключением строчных значений, отладчик нечувствителен
к разряду символов[fn:1].  Эстетика языка Common Lisp, однако,
предполагает использование нижнего разряда во всех случаях где разряд
не имеет значения.

***** Основание используемое при печати/чтении чисел

По умолчанию =*PRINT-BASE*=, переменная задающая основание используемое для печати чисел,
имеет значение равное 16; установитьеё значение в 10 можно следующим образом:

      : setf *print-base* #xa

По умолчанию =*READ-BASE*=, переменная задающая основание используемое для чтения вводимых чисел,
имеет значение равное 10; установить её значение в 16 можно следующим образом:

      : setf *read-base* #x10

или,

      : expert

***** Различия в способах указания путей к файлам в Linux и Windows

В среде Linux пути указываются каноническим для UNIX-систем образом:

: "/path/to/foo"

однако в Windows, обычные для разделителей компонентов пути в этой системе
обратные слэши заменены на прямые:

: "d:/path/to/foo"

*** Различие между синтаксисами интерактивного и пакетного режимов
     
Синтаксисы интерактивного и пакетного режимов имеют различие обусловленное
стремлением упростить работу в интерактивном режиме.  Корень различия
заключается в необходимости заключения всех вызовов функций и макросов
в круглые скобки, связанной с требованиями языка Лисп.

Очевидно что в интерактивном режиме это требование крайне неудобно,
т.к. требует ручного ввода двух, строго говоря необязательных, символов
в каждой команде.  Более того, абсолютная необходимость в скобках привела
бы к невозможности реализации режима ограниченной совместимости с набором
команд отладчика MDB.

В связи с этим, в интерактивном режиме реализована возможность опускать
внешний уровень скобок.

Пакетный режим в данный момент не предоставляет такой возможности[fn:2].

*** Интерактивный режим
*** Режим пакетного исполнения
    Отладчик позволяет выполнять команды из файлов, при этом файлы команд могут
содержать комментарии, пустые строки и команды исполнения других файлов.

Комментарии бывают двух видов:

    - строчно ориентированные: начинаются с символа ';' и продолжаются до конца строки;
    - блочно-ориентированные: начинаются с подстроки "#|" и заканчиваются подстрокой "|#".

В связи с тем что, как уже было отмечено выше, пакетный режим накладывает необходимость
окружения каждой отдельной команды скобками, в одной строке файла могут находиться несколько команд.

*** Отладчик отладчика

При возникновении исключительных ситуаций (в т.ч. ошибок) в обоих
режимах исполнения активируется отладчик среды Common Lisp, в котором
также можно исполнять команды comdb, а также активировать т.н. /рестарты/ -
реакции заготовленные на случаи возникновения исключительных ситуаций
в данном контексте.

Активация рестарта позволяет продолжить исполнение тем или иным образом.
Выбор рестартов осуществляется вводом либо соответствующего ему номера,
либо сокращения от его имени, префиксированного ':'

#+BEGIN_VERSE
        /0-9/ - выбрать соответствующий рестарт
        /:a/  - выбрать самый верхний рестарт с именем начинающимся на A
#+END_VERSE
* Запуск отладчика
*** Параметры командной строки

#+BEGIN: comdb-help :path "~/source/common-db/"
/bin/bash: ./comdb-ru: No such file or directory

#+END

   - параметр =--core-multiplier= интерпретируется как десятичное целое, в других случаях
     всё что похоже на целое число, воспринимается как шестнадцатиричное[fn:3];
   - параметр =--load= интерпретируется как строка;
   - иначе объект воспринимается как Лисп-выражение

* Интерфейс
  Ниже следуют описание глобальных переменных и команд, представляющих
собой часть пользовательского интерфейса.  Команды реализованы в виде обычных
функций языка Common Lisp, и, как следствие, соглашение передачи аргументов
соответствует соглашению принятому в Common Lisp.  Первый раздел данной главы
описывает этот механизм.

*** Терминология специфичная для тематики связанной с передачей аргументов функциям в языке Common Lisp
  - <<<лямбда-список>>> ::
    Список задающий набор параметров и протокол получения значений для этих параметров.
  - <<<аргумент>>> ::
    Объект представляемый в качестве входных данных функции, в момент её вызова.
  - <<<параметр>>> ::
    Переменная в определении функции, принимающая значение соответствующего аргумента (или списка соответствующих аргументов)
    данной функции в момент её вызова, или, в некоторых случаях, получающая значение по умолчанию, потому что соответствующего
    аргумента нет.
  - <<<спецификатор параметра>>> ::
    Выражение, являющееся частью лямбда-списка, представляющее собой символ или список, используемое для задания параметра,
    и интерпретируемое в контексте
    - ключевых слов лямбда-списка, и
    - параметров заданных указанными ранее спецификаторами параметров.

*** Соглашение о передаче аргументов, лямбда-списки
Лямбда-список это список задающий набор параметров (иногда называемых лямбда-переменными),
и протокол принятия этих параметров.  В данном контексте используется только один тип
лямбда-списков -- т.н. обычный лямбда-список.

Обычный лямбда-список может содержать следующие ключевые слова лямбда-списка[fn:4]:

  - &allow-other-keys
  - &key
  - &optional
  - &rest

Каждый элемент лямбда-списка является либо спецификатором параметра, либо ключевым словом
лямбда-списка.  Упрощённый синтаксис обычного лямбда-списка таков[fn:5]:

 : lambda-list::= (var*
 :                 [&optional {var | (var [init-form])}*]
 :                 [&rest var]
 :                 [&key {var | (var [init-form])}* [&allow-other-keys]])

Инициализационные формы INIT-FORM могут представлять собой любые формы.
Обычный лямбда-список имеет четыре интересующих нас части, любая, или каждая из которых может быть пустой.

***** Спецификаторы обязательных параметров
Это все спецификаторы параметров до первого ключевого слова лямбда-списка; если ключевые слова лямбда-списка отсутствуют,
тогда все спецификаторы задают обязательные параметры.

Если присутствуют N обязательных параметров (N может быть равно нулю), то должно быть передано как минимум N аргументов,
и переменные обязательных параметров привязываются к первым N из переданных аргументов.  Остальные параметры, затем,
обрабатываются с использованием каких-либо оставшихся аргументов.

***** Спецификаторы опциональных параметров
Если присутствует &optional, то спецификаторами опциональных параметров являются те что следуют за &optional, и до следующего
ключевого слова лямбда-списка, либо конца списка.  Если опциональные параметры заданы, тогда каждый из них обрабатывается следующим
образом.  Если остаются необработанные аргументы, тогда переменная параметра привязывается к следующему аргументу, также как
и в случае с обязательными параметрами.  Если, однако, аргументов более не осталось, тогда вычисляется INIT-FORM и переменная
параметра привязывается к полученному значению (или nil, если INIT-FORM не указана в спецификаторе параметра).

***** Спецификатор остаточного параметра
&rest, когда оно присутствует, должно быть сопровождено следующим за ним едиственным спецификатором остаточного параметра, за которым,
в свою очередь, должно следовать либо другое ключевое слово лямбда-списка, либо окончание лямбда-списка.  После того как были
обработаны спецификаторы всех опциональных параметров, может присутствовать, а может и не присутствовать остаточный параметр.
Если остаточный параметр присутствует, он привязывается к списку всех необработанных к данному моменту аргументов.
Если необработанных аргументов не осталось, остаточный параметр привязывается к пустому списку.  Если остаточный параметр отстутствует,
и нет ключевых параметров, тогда, при наличии необработанных аргументов, должна сигнализироваться ошибка.

***** Спецификатор ключевых параметров
Если &key присутствует, все спецификаторы до следующего ключевого слова лямбда-списка, либо до конца лямбда-списка являются
спецификаторами ключевых параметров.  При обработке ключевых параметров, обрабатываются те же аргументы что попали бы в список
остаточного параметра.  Разрешено указывать вместе &rest и &key.  В этом случае, остающиеся аргументы используются для обоих целей;
то есть, все остающиеся аргументы собираются в список для остаточного параметра, и, одновременно обрабатываются в качестве
параметров &key.  Если &key указан, то должно оставаться чётное количество аргументов.  Эти аргументы рассматриваются как пары,
причём первый элемент в каждой паре интерпретируется в качестве имени, а второй в качестве соответствующего значения.  Первый объект
в каждой паре должен быть символом.  Спецификаторы ключевых параметров могут опционально сопровождаться ключевым словом лямбда-списка
&allow-other-keys.

Каждый спецификатор ключевого параметра должен содержать имя переменной параметра.  Имя ключевого слова используемое для совмещения
аргументов и параметров является символом в пакете KEYWORD (чья печатная форма, стало быть, префиксируется двоеточием), чьё имя равно
имени переменной параметра.

Спецификаторы ключевых параметров, как и все спецификаторы параметров, фактически обрабатываются слева-направо.  Для каждого
спецификатора ключевого параметра, при наличии пары аргументов чей именной компонент совпадает с именем спецификатора,
производится привязывание переменной параметра ко второму элементу (значению) этой пары аргументов.  Если более чем одна
пара аргументов подходит, то используется самая левая из них.  Если ни одна пара аргументов не подходит, то вычисляется INIT-FORM
данного спецификатора параметра, и переменная параметра привязывается к полученному значению (или к nil, если INIT-FORM не указана).
Если проверка ключевых аргументов не отключена, то пары аргументов должны содержать имена соответствующие именам спецификаторов
параметров.

Если проверка ключевых аргументов отключена, тогда парам аргументов разрешается не совпадать ни с каким из спецификаторов
параметров, и тогда такие пары игнорируются, оставаясь, однако, доступными через остаточный параметр, если таковой был указан.

***** Примеры обычных лямбда-списков
Вот несколько примеров использующих опциональные и остаточные параметра:

#+BEGIN_SRC emacs-lisp
  ((lambda (a b)
     (+ a (* b 3)))
   4 5)
 =>  19
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a &optional (b 2))
     (+ a (* b 3)))
   4 5)
 =>  19
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a &optional (b 2))
     (+ a (* b 3)))
   4)
 =>  10
#+END_SRC

Вот несколько примеров использующих ключевые параметры:

#+BEGIN_SRC emacs-lisp
  ((lambda (a b &key c d)
     (list a b c d))
   1 2)
 =>  (1 2 NIL NIL)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a b &key c d)
     (list a b c d))
   1 2 :c 6)
 =>  (1 2 6 NIL)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a b &key c d)
     (list a b c d))
   1 2 :d 8)
 =>  (1 2 NIL 8)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a b &key c d)
     (list a b c d))
   1 2 :c 6 :d 8)
 =>  (1 2 6 8)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a b &key c d)
     (list a b c d))
   1 2 :d 8 :c 6)
 =>  (1 2 6 8)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a b &key c d)
     (list a b c d))
   :a 1 :d 8 :c 6)
 =>  (:a 1 6 8)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a b &key c d)
     (list a b c d))
   :a :b :c :d)
 =>  (:a :b :d NIL)
#+END_SRC

Вот несколько примеров использующих опциональные, остаточные и ключевые параметры вместе:

#+BEGIN_SRC emacs-lisp
  ((lambda (a &optional (b 3) &rest x &key c (d a))
     (list a b c d x))
   1)
 =>  (1 3 NIL 1 ())
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a &optional (b 3) &rest x &key c (d a))
     (list a b c d x))
   1 2)
 =>  (1 2 NIL 1 ())
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a &optional (b 3) &rest x &key c (d a))
     (list a b c d x))
   :c 7)
 =>  (:c 7 NIL :c ())
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a &optional (b 3) &rest x &key c (d a))
     (list a b c d x))
   1 6 :c 7)
 =>  (1 6 7 1 (:c 7))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a &optional (b 3) &rest x &key c (d a))
     (list a b c d x))
   1 6 :d 8)
 =>  (1 6 NIL 8 (:d 8))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ((lambda (a &optional (b 3) &rest x &key c (d a))
     (list a b c d x))
   1 6 :d 8 :c 9 :d 10)
 =>  (1 6 9 8 (:d 8 :c 9 :d 10))
#+END_SRC


#+BEGIN: comdb-command-documentation :path "~/source/common-db/"
*** Управляющие переменные
     - =*disable-usb*= ::

     - =*display*= ::

     - =*examine-tlb*= ::

     - =*explain*= ::

     - =*force-memory-detection*= ::

     - =*forced-platform*= ::

     - =*inhibit-memory-detection*= ::

     - =*keep-target-intact*= ::

     - =*log-bus-events*= ::

     - =*log-core-pipeline-crit*= ::

     - =*log-graft-access*= ::

     - =*log-interface-bus-discovery*= ::

     - =*log-loadable-processing*= ::

     - =*log-platform-processing*= ::

     - =*log-state-changes*= ::

     - =*log-stream*= ::
       Global log stream for the whole debugger.

     - =*log-system-configuration*= ::

     - =*log-tap-register-access*= ::

     - =*map-to-zeroth-page*= ::

     - =*memory-detection-threshold*= ::

     - =*orgify*= ::

     - =*print-backtrace-on-errors*= ::

     - =*verbose-interface-init*= ::

     - =*watch*= ::

     - =*watch-fn*= ::

*** Документация
     - ? what ::
       Вывести справку по связанной с символом WHAT командой или категорией команд.

     - help &optional what ::
       Вывести справку по связанной с символом WHAT командой или категорией команд, 
       если он задан.  Если WHAT не указан, вывести перечень категорий.

     - apropos string-designator &optional package external-only ::
       Коротко описать все символы содержащие указанную STRING.
       Если указан PACKAGE, то описать лишь символы присутствующие в этом пакете.  
       Если указан EXTERNAL-ONLY, тогда описывать только символы эскпортируемые данным пакетом.

     - describe object &optional (stream-designator =*standard-output*=) ::
       Вывести описание OBJECT.

*** Устройства
     - scan &optional force-rescan ::
       Функция производит следующие операции:
       
         - поиск адаптеров подключенных к EPP и USB,
         - для каждого подключенного адаптера:
           - анализ OnCD подключенного к адаптеру целевого устройства,
           - определение типа платформы целевого устройства,
           - инициализацию компонентов платформы целевого устройства.
       
       Если функции первым параметром передан не-NIL, то производится повторный анализ
       уже найденных к данному моменту адаптеров с подключенными к ним целевыми устройствами.
       
       При нескольких подключенных устройствах, активным становится последнее найденное.
       При этом, следует отметить что шина USB сканируется после портов EPP, что, как следствие,
       придаёт адаптерам на шине USB определённый приоритет.

     - compile-memconfig name ::
       Вывести список пар адрес-значение соответствующих названной конфигурации памяти.

     - list-memconfigs ::
       Вывести список имён конфигураций памяти потенциально применимых
       к текущему целевому устройству.

     - set-memconfig name &key test (test-size 10000) remember ::
       Применить конфигурацию памяти с именем NAME.
       
       Принимаются следующие ключевые аргументы:
         - TEST ::
           По применении конфигурации проверить её работоспособность,
           произведя тест памяти.
         - TEST-SIZE ::
           Задать размер тестирования.
         - REMEMBER ::
           Запомнить данную конфигурацию для активного целевого устройства,
           что приведёт к её использованию во время перенастройки при сбросе.

     - explain-memconfig &optional name ::
       Детально, по битовым полям, разобрать структуру конфигурации памяти
       с именем NAME.  Если имя не указано, разобрать текущую настройку.

     - list-contexts ::
       Вывести список контекстов обнаруженных целевых устройств.

     - ctx &optional id ::
       При отсутствии параметров, вывести список целевых контекстов,
       содержащийся в переменной =*TARGET-CONTEXTS*=.
       При наличии параметра, интерпретировать его как номер контекста,
       если это число, либо идентификатор контекста, если это список,
       который следует сделать теукщим.

*** Ввод/вывод
     - clearmem address length &optional (value 0) ::
       Установить диапазон ячеек памяти начиная с ADDRESS и длиной LENGTH
       байт в значение параметра VALUE (0-255).

     - loadelf filename &key check ::
       Загрузить содержимое FILENAME в формате ELF в память устройства
       и установить точку входа.
       
       Принимаются следующие ключевые аргументы:
         - CHECK ::
           включить проверку целостности записи.

     - loadbin filename address &key check ::
       Загрузить сырые байты из FILENAME по ADDRESS.
       
       Принимаются следующие ключевые аргументы:
         - CHECK ::
           включить проверку целостности записи.

     - savebin filename address length ::
       Сохранить содержимое диапазона ячеек памяти начиная с ADDRESS
       и длиной LENGTH байт в FILENAME, в сыром виде.

     - loadeltext filename &key (entry-point bfc00000) check ::
       Загрузить содержимое FILENAME в текстовом формате 'eltext' в память
       устройства и установить точку входа.
       
       Принимаются следующие ключевые аргументы:
         - CHECK ::
           включить проверку целостности записи.
       
         - ENTRY-POINT ::
           установить точку входа.

     - saveeltext filename address length ::
       Сохранить содержимое диапазона ячеек памяти начиная с ADDRESS и
       длиной LENGTH байт в FILENAME, в формате 'eltext'.
       
       ADDRESS и LENGTH должны быть выровнены по 16.

     - loadldr filename &key check ::
       Загрузить содержимое FILENAME в формате LDR-MCS в память устройства
       и установить точку входа.
       
       Принимаются следующие ключевые аргументы:
         - CHECK ::
           включить проверку целостности записи.

*** Управление состоянием
     - reset &rest platform-args &key (core =*core*=) (state =*depth*=) &allow-other-keys ::
       Функция сбрасывает и перенастраивает целевое устройство содержащее ядро CORE
        (по умолчанию выбирается являющееся активным в данный момент), с учётом ключевых аргументов PLATFORM-ARGS.
       Производятся следующие действия:
       
         * осуществляется попытка выяснения текущие значения делителей частоты;
         * кристалл сбрасывается в первоначальное состояние;
         * системные компоненты перенастраиваются с использованием либо сохранённых значений
           делителей частоты, либо значений по умолчанию для данной платформы.
         * устанавливается соответствующая текущим настройкам глубина режима отладки (по умолчанию – :DEBUG).

     - dive ::
       Войти в более глубокий режим отладки, или остановить целевое устройство.
       Схема состояний: :FREE -> :STEP -> :DEBUG.

     - rise ::
       Войти в более лёгкий режим отладки, или запустить целевое устройство.
       Схема состояний :DEBUG -> :STEP -> :FREE.

     - run &rest params &key (core =*core*=) (explain =*explain*=) (display =*display*=) (watch =*watch*=) (watch-fn =*watch-fn*=) (iteration-period 989680) (watch-period 64) &allow-other-keys ::
       Вывести ядро CORE из режима отладки, запустить его, дождаться его останова
       и войти в режим отладки.
       
       Принимаются следующие ключевые аргументы:
         - ADDRESS ::
           заместить содержимое регистра адреса выбираемой инструкции,
           и как следствие, перевести поток исполнения на заданный адрес.

     - run-async &rest params &key address state-determined (core =*core*=) &allow-other-keys ::
       Вывести целевое устройство из режима отладки и запустить его асинхронно,
       не дожидаясь.
       
       Принимаются следующие ключевые аргументы:
         - ADDRESS ::
           заместить содержимое регистра адреса выбираемой инструкции,
           и как следствие, перевести поток исполнения на заданный адрес.

     - run-until-stopped-by reason &rest run-params &key (otherwise :report-and-continue) &allow-other-keys ::
       Запустить кристалл, дождаться останова, анализируя затем его причину и
       возвращая успех при совпадении причины со значением параметра REASON.
       Реакция на несовпадение определяется значением ключевого параметра OTHERWISE,
       интерпретируемого следующим образом:
         - :RETURN ::
           вернуть ложный статус,
         - :CONTINUE ::
           продолжить цикл,
         - :REPORT-AND-CONTINUE :: 
           продолжить цикл, отобразив причину останова.
       
       Остаточные параметры (за исключением OTHERWISE) передаются команде RUN.

     - run-while-boring &rest boring-syms ::
       Запустить целевое устройство, продолжая затем запускать его, при остановах,
       до тех пор пока при очередном останове на конвейере не появятся адреса не покрытые
       символами из остаточного списка параметров.

     - run-while-step-in address &optional (nsteps 1) verbose &key (explain =*explain*=) (display =*display*=) ::
       Запустить целевое устройство, осуществляя NSTEPS шагов при остановах и
       проводя сравнение регистра адреса выбираемой инструкции со значением параметра
       ADDRESS, запуская кристалл дальше, в цикле, если сравнение успешно, и выходя
       из цикла в обратном случае.

     - step count &key (display =*display*=) ::
       Произвести COUNT шагов.

     - trace count &rest run-params ::
       Исполнить COUNT инструкций и остановиться.
       
       Остаточные параметры передаются команде RUN.

     - dspreset dsp-core-or-id ::
       Произвести аппаратный сброс DSP-ядра заданного через спецификатор DSP-ядра DSP-CORE-OR-ID.
       
       Примеры:
         : (dspreset (dsp 0))
         : (dspreset 0)

     - dsprun dsp-core-or-id &optional address ::
       Запустить DSP-ядро заданное через спецификатор DSP-ядра DSP-CORE-OR-ID с ADDRESS, 
       если он указан, либо просто продолжить поток исполнения, не вмешиваясь в конвейер,
       если ADDRESS не указан.  В любом случае, дождаться останова DSP-ядра.
       
       Примеры:
         : (dsprun (dsp 0) #x1010)
         : (dsprun 0 #x1010)

     - dspstep dsp-core-or-id &optional (count 1) ::
       Произвести COUNT шагов в DSP-ядре заданном через спецификатор DSP-ядра DSP-CORE-OR-ID.
       
       Примеры:
         : (dspstep (dsp 0))

     - dspstop dsp-core-or-id ::
       Ввести DSP-ядро заданное через спецификатор DSP-ядра DSP-CORE-OR-ID в режим останова.
       
       Примеры:
         : (dspstop (dsp 0))

     - explain &optional (core =*core*=) ::
       Отобразить причину останова ядра CORE.
       По умолчанию используется ядро текущего активного устройства.

     - leave-frame &rest run-params ::
       Установить точку останова в значение регистра R31, предположительно
       содержащий актуальный адрес возврата и выполнить команду RUN.
       
       Остаточные параметры передаются команде RUN.

*** Ловушки
     - hw-break break-or-id address &optional (skipcount 0) &key bound ::
       Установить аппаратную точку останова заданную через спецификатор
       аппаратной точки останова BREAK-OR-ID на адрес заданный через спецификатор
       адреса ADDRESS. Опциональный параметр SKIPCOUNT задаёт количество пропусков
       срабатывания.

     - sw-break address-or-symbol ::
       Установить программную точку останова на адрес заданный через
       спецификатор адреса ADDRESS-OR-SYMBOL.

     - watch break-or-id address &optional (skipcount 0) &key (read t) write bound ::
       Установить адресную ловушку точку заданную через спецификатор
       аппаратной точки останова BREAK-OR-ID на адрес заданный через спецификатор
       адреса ADDRESS. Опциональный параметр SKIPCOUNT задаёт количество пропусков
       срабатывания.

     - catch &rest catches ::
       Проинтерпретировать остаточный список параметров как набор спецификаторов
       векторных ловушек, и установить их. Интерпретация осуществляется следующим образом:
       
         - #xbfc00000, #xbfc, :bfc  ->  #xbfc00000
         - #x80000000, #x800, :800  ->  #x80000000
         - #x80000180, #x180, :180  ->  #x80000180
         - #x80000200, #x200, :200  ->  #x80000200
         - #xbfc00200  ->  #xbfc00200
         - #xbfc00380, #x380, :380  ->  #xbfc00380
         - #xbfc00400, #x400, :400  ->  #xbfc00400

     - trace count &rest run-params ::
       Исполнить COUNT инструкций и остановиться.
       
       Остаточные параметры передаются команде RUN.

     - settrace count ::
       Установить ограничитель количества исполняемых инструкций в COUNT.

     - clear-break address ::
       Удалить точку останова, будь то программную или аппаратную, установленную
       на ADDRESS.

     - clear-sw-breaks ::
       Удалить все программные точки останова.

     - disable-breaks ::
       Отключить все точки останова.

     - describe-breaks ::
       Описать все активные точки останова.

     - dspbreak dsp-core-or-id n address ::
       Установить N-ную точку останова DSP-ядра заданного через спецификатор DSP-ядра
       DSP-CORE-OR-ID в ADDRESS, если последний не-NIL.  В противном случае, отключить её.
       
       Примеры:
         : (dspbreak (dsp 0) 3 #x1010)
         : (dspbreak 0 3 #x1010)

*** DSP
     - dsp n ::
       Вернуть объект представляющий N-ное DSP-ядро.

     - dspbreak dsp-core-or-id n address ::
       Установить N-ную точку останова DSP-ядра заданного через спецификатор DSP-ядра
       DSP-CORE-OR-ID в ADDRESS, если последний не-NIL.  В противном случае, отключить её.
       
       Примеры:
         : (dspbreak (dsp 0) 3 #x1010)
         : (dspbreak 0 3 #x1010)

     - dspreset dsp-core-or-id ::
       Произвести аппаратный сброс DSP-ядра заданного через спецификатор DSP-ядра DSP-CORE-OR-ID.
       
       Примеры:
         : (dspreset (dsp 0))
         : (dspreset 0)

     - dsprun dsp-core-or-id &optional address ::
       Запустить DSP-ядро заданное через спецификатор DSP-ядра DSP-CORE-OR-ID с ADDRESS, 
       если он указан, либо просто продолжить поток исполнения, не вмешиваясь в конвейер,
       если ADDRESS не указан.  В любом случае, дождаться останова DSP-ядра.
       
       Примеры:
         : (dsprun (dsp 0) #x1010)
         : (dsprun 0 #x1010)

     - dspstep dsp-core-or-id &optional (count 1) ::
       Произвести COUNT шагов в DSP-ядре заданном через спецификатор DSP-ядра DSP-CORE-OR-ID.
       
       Примеры:
         : (dspstep (dsp 0))

     - dspstop dsp-core-or-id ::
       Ввести DSP-ядро заданное через спецификатор DSP-ядра DSP-CORE-OR-ID в режим останова.
       
       Примеры:
         : (dspstop (dsp 0))

*** Адреса и символы
     - addr address-or-symbol ::
       Проанализировать адрес заданный через спецификатор адреса ADDRESS-OR-SYMBOL,
       и выдать детальную информацию.

     - addrsym address ::
       Вернуть символ с наименьшим адресом, большим или равным ADDRESS.

     - nextaddr address ::
       Вернуть адрес символа следующего за ADDRESS в активной таблице символов.

     - nextsym symbol ::
       Вернуть символ следующий в активной таблице символов за SYMBOL.

     - prevaddr address ::
       Вернуть адрес символа предшедствующего ADDRESS в активной таблице символов.

     - symaddr symbol ::
       Вернуть адрес соответствующий SYMBOL.

     - symlength symbol ::
       Вернуть разницу между адресами SYMBOL и символа следующего за ним
       в активной таблице символов.

     - loadsyms pathname &key (type :system-map) ::
       Загрузить таблицу символов в формате TYPE из файла PATHNAME,
       и сделать эту таблицу активной.

     - register-address register ::
       Найти адрес регистра соответствующего спецификатору регистра REGISTER,
       в том случае если он соответствует регистру отображённому в память.

*** Анализ
     - disasm &optional address-or-symbol length line-pre-annotate-fn annotations ::
       Дизассемблировать содержимое диапазона ячеек памяти начиная с
       ADDRESS-OR-SYMBOL и длиной LENGTH.
       
       Значение параметра ADDRESS-OR-SYMBOL по умолчанию равно содержимому
       регистра адреса выборки конвейера уменьшенному на #x10.
       
       Значение параметра LENGTH по умолчанию равно либо #x20, если ADDRESS-OR-SYMBOL представляет собой целое,
       либо разнице между адресами символов ADDRESS-OR-SYMBOL и следующего за ним.

     - displash address &optional (splash-size 10) annotations ::
       Дизассемблирование адресов в коридоре вокруг ADDRESS.
       Величина коридора задаётся параметром SPLASH-SIZE.

     - dispack &optional (name :pipeline) ::
       Напечатать значения регистров из заготовленной пачки с именем NAME.

     - dump address-or-symbol &optional (length 100) ::
       Напечатать содержимое диапазона ячеек памяти начиная с ADDRESS-OR-SYMBOL
       и длиной LENGTH.

     - print-memory address length ::
       Напечатать содержимое диапазона ячеек памяти начиная с ADDRESS и
       длиной LENGTH, как текст.

     - print-tlb &optional (page-size 4000) ::
       Распечатать содержимое TLB.  Размер отображаемый страницей принимается
       равным PAGE-SIZE.

     - display &rest new-items ::
       Печатать значения регистров чьи имена находятся в /месте/
        (DISPLAY-LIST).  Когда команде передаются параметры, они замещают
       старое значение (DISPLAY-LIST).

     - edisplay ::
       Как DISPLAY, с добавлением типично востребованной информации:
       cop0.count, cop0.epc, cop0.badvaddr, cop0.cause и дизассемблированием
       адресов вокруг pcfetch и cop0.epc.

     - display-list ::
       /Место/ предоставляющее доступ к текущему списку отображения.

     - explain &optional (core =*core*=) ::
       Отобразить причину останова ядра CORE.
       По умолчанию используется ядро текущего активного устройства.

     - get name-or-address ::
       Получить регистр или ячейку памяти заданный/-ую через спецификатор адреса
       NAME-OR-ADDRESS, представляющем собой либо ключевое слово.

     - set name-or-address value ::
       Установить регистр или ячейку памяти заданный/-ую через спецификатор адреса
       NAME-OR-ADDRESS.  Также доступен синтаксис (setf (get NAME-OR-ADDRESS) VALUE).

     - peek address-or-symbol &optional verbose ::
       Напечатать содержимое ячейки по адресу ADDRESS-OR-SYMBOL, опционально,
       при указанном не-NIL значении параметра VERBOSE, расшифровывая значение
       ADDRESS-OR-SYMBOL в контексте активной таблицы символов.

     - show name-or-address ::
       Получить регистр или ячейку памяти заданный/-ую через спецификатор адреса
       NAME-OR-ADDRESS.  В том случае если указано имя регистра имеющего структуру,
       полученное значение разобирается по полям, и возвращается как второе значение
       функции.

     - pipeline ::
       Как DISPLAY, но анализирует лишь адреса на конвейере.

     - pipesyms ::
       Вернуть список имён функций соответствующих адресам на конвейере,
       используя активную таблицу символов.

*** Вмешательство
     - set name-or-address value ::
       Установить регистр или ячейку памяти заданный/-ую через спецификатор адреса
       NAME-OR-ADDRESS.  Также доступен синтаксис (setf (get NAME-OR-ADDRESS) VALUE).

*** Трассировка
     - trace count &rest run-params ::
       Исполнить COUNT инструкций и остановиться.
       
       Остаточные параметры передаются команде RUN.

     - block-trace size &optional count &rest run-args &key (state :stop) &allow-other-keys ::
       Произвести трассировку блоками, по SIZE инструкций в блоке.
       Если задан параметр COUNT не равный NIL, выйти после указанного им количества блоков.
       
       Остаточные параметры при каждом пуске передаются команде RUN.

     - count-trace addr-or-sym &rest run-args ::
       Установить аппаратную точку останова в адрес заданный через 
       спецификатор адреса ADDR-OR-SYM, и запускать целевое устройство, 
       выводя на экран счётчик остановов.
       
       Остаточные параметры при каждом пуске передаются команде RUN.

     - insn-trace size &key check (addr 0) (mask 7fffffff) (mode :trace) (print-syms t) full-pipeline ::
       Произвести пошаговую трассировку, длиной SIZE шагов, снимая значения регистров
       конвейера на каждом шагу.
       
       Принимаются следующие ключевые аргументы:
         - CHECK ::
           на каждом шагу проверять соответствие фактически декодируемого значения инструкции
           содержимому памяти по адресу указываемому соответствующим регистром конвейера (PCdec),
       
         - ADDR, MASK ::
           при осуществлении вышеуказанной проверки, осуществлять отображение регистра PCdec,
           путём замены битов не указанных в MASK соответствующими битами из ADDR,
       
         - MODE ::
           выбор механизма осуществления шага -- :STEP или :TRACE,
       
         - PRINT-SYMS ::
           разрешать значения адресов в регистре PCdec в символьные имена, используя активную таблицу символов,
       
         - FULL-PIPELINE ::
           снимать все регистры конвейера, а не только PCdec и IRdec.

     - staircase-trace callspecs &rest run-args ::
       Произвести т.н. "лестничную трассировку", состоящую из ступеней, задаваемых
       параметром CALLSPECS, каждая из которых содержит спецификатор адреса точки останова
       и количество пропусков данной точки для перехода к следующей ступени.
       
       Остаточные параметры при каждом пуске передаются команде RUN.

*** Прочее
     - sleep seconds ::
       Эта функция приостанавливает исполнение на SECONDS.  
       SECONDS могут быть любым неотрицательным реальным числом.

     - write-completions filename &optional (packages =*tui-completable-packages*=) qualified-packages ::
       Записать информацию для автодополнений символов из списка пакетов PACKAGES,
       в формате GNU Readline в FILENAME.  Имена символов из пакетов в списке
       QUALIFIED-PACKAGES дополняются префиксом из короткого имени пакета и
       символа двоеточия.

     - list-platforms ::
       Вывести список всех известных платформ.

     - version ::
       Вывести версию отладчика.
       Команда различает релизные версии и версии в разработке.

*** Грубое управление
     - load pathspec &key (verbose =*load-verbose*=) (print =*load-print*=) (if-does-not-exist t) (external-format :default) ::
       Загрузить файл указанный с помощью PATHSPEC, последовательно считывая
       и исполняя содержащиеся в нём формы.

     - quit &optional (status 0) ::
       Выйти из отладчика, не меняя состояние целевого устройства.

*** Тестирование
     - run-tests &optional all-contexts &rest test-suites ::
       Выполнить серию тестов из тестовых наборов, с названиями в остаточном списке
       параметров, на всех доступных устройствах.  По умолчанию используются тестовые наборы
       :INTERFACE и :TARGET.

     - testir ::
       Бесконечный цикл записи команды DEBUG REQUEST в регистр TAP IR,
       с печатью возвращаемого значения.

     - testmem &optional (address 0) (length 10000) ::
       Протестировать диапазон ячеек памяти длиной в LENGTH байт,
       начиная с ADDRESS.

*** Команды отладчика MDB получившие новое название
      - source [[file:~/source/mdb/src/cmd.c::void%20mdb_source%20int%20argc%20char%20argv][.]] => load :: 
      - load [[file:~/source/mdb/src/cmd.c::void%20mdb_load%20int%20argc%20char%20argv][.]] => loadeltext :: 
      - save [[file:~/source/mdb/src/cmd.c::void%20mdb_save%20int%20argc%20char%20argv][.]] => saveeltext :: 
      - dump-raw [[file:~/source/mdb/src/cmd.c::void%20mdb_dump_raw%20int%20argc%20char%20argv][.]] => dump ::
      - leave [[file:~/source/mdb/src/cmd.c::void%20mdb_leave%20int%20argc%20char%20argv][.]] => leave-frame ::
      - tlb [[file:~/source/mdb/src/cmd.c::void%20mdb_leave%20int%20argc%20char%20argv][.]] => print-tlb ::

      - version [[file:~/source/mdb/src/cmd.c::void%20mdb_version%20int%20argc%20char%20argv][.]] ::
      - conf [[file:~/source/mdb/src/cmd.c::void%20mdb_conf%20int%20argc%20char%20argv][.]] ::

      - epp [[file:~/source/mdb/src/cmd.c::void%20mdb_epp%20int%20argc%20char%20argv][.]] => set-epp :: 
      - jtag [[file:~/source/mdb/src/cmd.c::void%20mdb_jtag%20int%20argc%20char%20argv][.]] => set-jtag :: 

      - sbp [[file:~/source/mdb/src/cmd.c::void%20mdb_sbp%20int%20argc%20char%20argv][.]] => sw-break ::
      - bp [[file:~/source/mdb/src/cmd.c::void%20mdb_watchpoint%20int%20argc%20char%20argv][.]] => hw-break ::
      - wp [[file:~/source/mdb/src/cmd.c::void%20mdb_watchpoint%20int%20argc%20char%20argv][.]] => watch ::

      - drun [[file:~/source/mdb/src/cmd.c::void%20mdb_drun%20int%20argc%20char%20argv][.]] => dsprun :: 
      - dstep [[file:~/source/mdb/src/cmd.c::void%20mdb_dstep%20int%20argc%20char%20argv][.]] => dspstep :: 
      - dbp [[file:~/source/mdb/src/cmd.c::void%20mdb_dbp%20int%20argc%20char%20argv][.]] => dspbreak ::
      - dspbp [[file:~/source/mdb/src/cmd.c::void%20mdb_dspbp%20int%20argc%20char%20argv][.]] => dspbreak (sort of) ::

      - expert [[file:~/source/mdb/src/cmd.c::void%20mdb_expert%20int%20argc%20char%20argv][.]] ::
      - eset [[file:~/source/mdb/src/cmd.c::void%20mdb_eset%20int%20argc%20char%20argv][.]] :: 
      - eshow [[file:~/source/mdb/src/cmd.c::void%20mdb_eshow%20int%20argc%20char%20argv][.]] :: 
      - estep [[file:~/source/mdb/src/cmd.c::void%20mdb_estep%20int%20argc%20char%20argv][.]] :: 
      - erun [[file:~/source/mdb/src/cmd.c::void%20mdb_erun%20int%20argc%20char%20argv][.]] :: 
      - eruntrace [[file:~/source/mdb/src/cmd.c::void%20mdb_eruntrace%20int%20argc%20char%20argv][.]] ::
      - etrace [[file:~/source/mdb/src/cmd.c::void%20mdb_etrace%20int%20argc%20char%20argv][.]] :: 

      - halt [[file:~/source/mdb/src/cmd.c::void%20mdb_halt%20int%20argc%20char%20argv][.]] :: 
      - runonly [[file:~/source/mdb/src/cmd.c::void%20mdb_runonly%20int%20argc%20char%20argv][.]] ::
      - runloop [[file:~/source/mdb/src/cmd.c::void%20mdb_runloop%20int%20argc%20char%20argv][.]] ::
      - wait [[file:~/source/mdb/src/cmd.c::void%20mdb_wait%20int%20argc%20char%20argv][.]] :: 
      - exit [[file:~/source/mdb/src/cmd.c::void%20mdb_quit%20int%20argc%20char%20argv][.]] :: 

      - testoncd [[file:~/source/mdb/src/cmd.c::void%20mdb_testoncd%20int%20argc%20char%20argv][.]] :: 

* Описание ключевых операций
*** Инициализация
    Инициализация бывает двух сортов:
    - первичная, включающая процессы поиска и анализа подключенных целевых устройств;
      инициализирует все найденные новоподключенные устройства.
    - повторная, без поиска устройств;
      инициализирует текущее активное устройство.

***** Первичная инициализация
      - scan &optional force-rescan => <нет значений> ::
        
        Функция производит следующие операции:
        - поиск адаптеров подключенных к EPP и USB,
        - для каждого подключенного адаптера:
          - анализ OnCD подключенного к адаптеру целевого устройства,
          - определение типа платформы целевого устройства,
          - инициализацию компонентов платформы целевого устройства.

        Если функции первым параметром передан не-NIL, то производится повторный
        анализ уже найденных к данному моменту адаптеров с подключенными к ним
        целевыми устройствами.

        При нескольких подключенных устройствах, активным становится последнее найденное.
        При этом, следует отметить что шина USB сканируется после портов EPP, что, как следствие,
        придаёт адаптерам на шине USB некоторый "приоритет".

******* Поиск адаптеров
********* EPP
          Производится запрос на получение привилегий доступа к портам EPP.  На UNIX-системах это осуществляется
          путём вызова системной функции iopl().  В Windows используется внешний, поставляемый с отладчиком сервис
          mcdbio.sys.

          - bus-probe-address (o parport-bus) address => <булево значение> ::
            Младшие три бита статусного регистра портов с адресами #x378, #x279, #xbc0 и #xb80 проверяются
            на значения 1 и 2, интерпретируемые в качестве версии адаптера.

********* USB
          - В UNIX: bus-occupied-addresses (o ezusb-bus) => <список адресов> ::
          - В Windows: bus-probe-address (o ezusb-bus) address => <булево значение> ::

            Производится серия запросов к ОС, осуществляющих поиск устрйств с USB ID #x0547:#x1002.  На UNIX-системах это
            осуществляется напрямую через системные интерфейсы sysfs и usbfs.  В Windows используется специальный драйвер
            ezusb.sys.
      
******* Анализ OnCD подключенного целевого устройства
        - bus-populate-address (o ezusb-bus) address => <интерфейс> ::
        - bus-populate-address (o parport-bus) address => <интерфейс> ::

          Производится сброс адаптера, затем TAP. Одновременно с этим выполняется команда TAP IDCODE.

        - find-target-class-for-interface interface &optional (if-does-not-exist :error) => <тип OnCD> ::

          Возвращённое командой TAP IDCODE значение интерпретируется как идентификатор целевого устройства.
          Текущий набор распознаваемых идентификаторов -- 2 и 3, соответствующие механизмам OnCD до NVCom,
          и начиная с него.

******* Определение типа платформы целевого устройства
        - detect-target-platform target &optional (if-does-not-exist :error) => <платформа> ::

          Функция производит считывание ячейки памяти по физическому адресу #x18480108,
          что соответствует адресу идентификационного регистра первого DSP (когда он присутствует
          на целевом устройстве), интерпретирует полученное значение как версию DSP и использует её
          для выбора платформы.

          Этот механизм имеет слабые стороны:
            - не все платформы имеют DSP, и как следствие идентификационный регистр,
            - некоторые платформы имеют DSP с одинаковыми идентификационными регистрами.

******* Инициализацию компонентов платформы целевого устройства
        В рамках этого этапа производятся следующие три шага:

********* Определение набора компонентов целевого устройства
          - populate-target (o target) => <нет значений> ::

            Определение набора компонентов целевого устройства, исходя из предопределённого списка
            компонентов соответствующей платформы.

            Именно в данный момент определяются типы RISC- и DSP- ядер, механизмов системного
            управления и диапазоны платформенной памяти (за исключением CRAM).

********* Первичная инициализация платформенных устройств
          - init-target-platform (o target) (p multicore-platform) => <нет значений> ::
          
            Первичная инициализация платформенных устройств, в рамках которой производится определение
            фактического размера памяти CRAM.  Для получения этого значения не используется
            предопределённый список платформенных устройств, т.к. последний составляется людьми,
            и, как следствие, может содержать ошибки -- при том что точный размер CRAM является важным
            для функционирования некоторых компонентов отладчика.

********* Настройка системных компонентов платформы целевого устройства
          - configure-target-platform (o target) (p platform) &key prereset-core-multiplier core-multiplier inhibit-memory-detection force-memory-detection (error-on-failed-detection t) => <булево значение> :: 

            Эта функция, в свою очередь, опирается на нижеследующие, причём
            определение и настройка основной памяти является опциональной.

*********** Настройка делителей частоты и системы управления питанием
            - configure-platform-system (p platform) (s system) &key core-multiplier => <нет значений> ::

              Производится настройка делителей частоты кристалла и системы управления питанием.

*********** Определение и настройка основной памяти
            - configure-target-memory target &optional force-detection (error-on-failed-detection t) => <нет значений> ::

              Среди набора известных значений настройки ChipSelect-ов и контроллера SDRAM производится поиск
              работающих для данной платы целевого устройства, в том случае если таковой не был найден ранее.

              При указанном ключе FORCE-DETECTION подбор производится несмотря на наличие уже найденного набора.

***** Повторная инициализация
      - reset &rest platform-args &key (core =*core*=) (state =*depth*=) &allow-other-keys => <нет значений> ::

        Функция сбрасывает и перенастраивает целевое устройство содержащее ядро CORE (по умолчанию выбирается являющееся активным в данный момент), 
        с учётом ключевых аргументов PLATFORM-ARGS.
        Производятся следующие действия:
        - осуществляется попытка выяснить текущие значения делителей частоты;
        - кристалл сбрасывается в первоначальное состояние;
        - системные компоненты перенастраиваются с использованием либо сохранённых значений делителей частоты,
          либо значений по умолчанию для данной платформы.
        - устанавливается соответствующая текущим настройкам глубина режима отладки (по умолчанию -- :DEBUG).

******* Определение текущего значения делителя частоты кристалла.
        - platform-core-frequency-multiplier platform system core => <целое число> ::

******* Сброс кристалла в первоначальное состояние
        - reset-target-platform (o target) (p platform) &rest platform-args &key stop-cores-p &allow-other-keys => <нет значений> ::

          Данная функция опирается на нижеследующие:

********* Сброс целевого устройства стредствами TAP
          - interface-reset-target (o parport-interface) stop-cores-p ::
          - interface-reset-target (o ezusb-interface) stop-cores-p ::

            Средствами адаптера осуществляется аппаратный сброс целевого устройства, после чего выполняются
            команды TAP DEBUG REQUEST и DEBUG ENABLE.

********* Инициализация состояния RISC-ядер
          - reset-core (core mips-core) ::

            Эта функция убирает все активные точки останова и сбрасывает все ведомые ядра (т.е. DSP).

********* Настройка системных компонентов платформы целевого устройства
          Эта функция была описана выше, см. [[configure%20target%20platform%20o%20target%20p%20platform][Настройка системных компонентов платформы целевого устройства]].

******* Установка глубины режима отладки
        - (setf state) new-state core &rest transition-args ::

          Управление состоянием отладки ядра CORE.

          Параметр NEW-STATE может принимать одно из следующих состояний:
            - :DEBUG, для глубокого, инвазивного режима отладки, с полностью доступным функционалом отладчика;
            - :STOP, для режима минимального вмешательства;
            - :FREE, запуск ядра.

* Существенные недостатки
  - отсутствие поддержки отладки DSP-ядер семейства кристаллов до NVCom;
  - отсутствие механизма автодополнения команд в интерактивном режиме в Windows,
    и сколько-либо приемлимого механизма редактирования строки в Linux вообще[fn:6];
  - лишь частичная поддержка системы команд mdb;
  - отсутствие поддержки сценариев в формате mdb;
  - отсутствие механизма асинхронного запроса прерывания исполнения и выхода из режима отладки
    на платформе Windows.
* Словарь
  - <<<адаптер>>> ::
    Устройство посредством которого осуществляется сообщение между вычислительной системой разработчика и JTAG TAP на плате целевого устройства.
    Различаются адаптеры следующим образом: 1. по размещению -- встроенные на плате и внешние, 2. по стандарту обмена данных -- EPP и USB.
  - <<<ключевое слово>>> ::
    Символ из пакета KEYWORD.  Печатная форма символа префиксирована символом двоеточия.  Пример: :FOO.
  - <<<опциональный параметр>>> ::
    Параметр чей соответствующий позиционный аргумент необязателен.
    Если аргумент не задан используется значение по умолчанию.
  - <<<ключевой параметр>>> ::
    Параметр чей соответствующий ключевой аргумент необязателен (обязательные ключевые аргументы не существуют).
    Если аргумент не задан используется значение по умолчанию.
  - <<<ключевые слова лямбда-списка>>> ::
    Символы, чьи имена начинаются с амперсанда (символа '&') и распознаются в лямбда-списках специальным образом.
  - <<<обычный лямбда-список>>> ::
    Лямбда-список используемый для определения набора параметров функций и протокола их принятия ею в языке Common Lisp.
  - <<<остаточный параметр>>> ::
    Параметр, который был учреждён с помощью ключевого слова лямбда-списка &rest.
  - <<<символ>>> ::
    1. В контексте программы целевого устройства: идентификатор связанный при помощи таблицы символов с адресом.
    2. В контексте языка Common Lisp: объект типа символ, использующийся для именования различных сущностей.
  - <<<спецификатор адреса>>> ::
    Объект обозначающий адрес и являющийся одним из: символ (обозначающий адрес связанный с данным символом в активной таблице символов),
    или неотрицательное целое (обозначающее адрес).
  - <<<спецификатор аппаратной точки останова>>> ::
    Объект обозначающий аппаратную точку останова и являющийся одним из: неотрицательное целое (обозначающий аппаратную точку останова
    с соответствующим номером), аппаратная точка останова (обозначающая саму себя).
  - <<<спецификатор программной точки останова>>> ::
    Объект обозначающий программную точку останова и являющийся одним из: неотрицательное целое (обозначающий программную точку
    останова установленную на соответствующий адрес), программная точка останова (обозначающая саму себя).
  - <<<спецификатор DSP-ядра>>> ::
    Объект обозначающий DSP-ядро и являющийся одним из: неотрицательное целое (обозначающее соответствующее DSP-ядро активного целевого
    устройства), DSP-ядро (обозначающее само себя).
  - <<<целевое устройство>>> ::
    Аппаратный компонент предмета отладки.
* Footnotes

[fn:1] Почти. В данном контексте пользователь вряд ли столкнётся с
[[http://www.lispworks.com/documentation/HyperSpec/Body/02_b.htm#multiple_escape][пунктом 6 статьи 2.2 спецификации ANSI Common Lisp]].

[fn:2] На данный момент.  Возможна реализация специального, строчно-
ориентированного режима интерпретации файлов с расширением ".cmd",
специально для удобства взаимодействия с имеющейся базой скриптов
написанных для отладчика MDB.

[fn:3] Другими словами, значение переменной =*READ-BASE*= во время
чтения параметров командной строки равно #x10.

[fn:4] На самом деле обычные лямбда-списки в Common Lisp определяют
ещё и ключевое слово &aux, но в данном контексте он не существенен.

[fn:5] Опущено ключевое слово &aux, спецификатор указанности необязательных
аргументов supplied-p и механизм переименовывания.
См. главу 3.4.1 спецификации Common Lisp:
 http://www.lispworks.com/documentation/HyperSpec/Body/03_da.htm

[fn:6] Ввиду наличия в Linux программы rlwrap, прозрачно добавляющей отличный механизм
редактирования строки и достаточно приемлимый механизм автодополнения, на этой платформе
эта проблема стоит не так остро.  Впрочем, в Windows командная оболочка предоставляет
консольным приложениям сервис редактирования строки, так что и там дела обстоят не совсем
плохо.
